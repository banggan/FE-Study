### 字符串（0811-0815）
#### 正则相关
- 替换空格
    ```javascript
    //请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy。则经过替换之后的字符串为We%20Are%20Happy。
    //思路1:直接用空格将字符串切割成数组，在用%20链接
    var replaceSpace = function(str){
        return str.split(' ').join('%20')
    }
    //思路2:用正则表达式找到所有空格依次替换
    var replaceSpace2 = function(str){
        return str.replace(/\s/g,'%20')
        //允许出现多个空格，多个空格用一个20%替换：
        return str.replace(/\s+/g,'%20')//连续空格替换
    }

    ```
- 正则表达式匹配
    ```javascript
    //实现一个函数用来匹配包括'.'和''的正则表达式。 模式中的字符'.'表示任意一个字符，而''表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。 例如，字符串"aaa"与模式"a.a"和"abaca"匹配，但是与"aa.a"和"ab*a"均不匹配
    ```
#### 其他
- 验证回文
    ```javascript
    //回文，即以位于正中间的数字为中点进行分割，两边的数据完全对称。
    //所以，如果设定一个循环，从整数第一位下标开始，第一位与最后一位对比，第二位与倒数第二位对比，回文两边的数字会全部相等，循环次数最大值为Math.floor(x.length/2), 而如果不一致，则判断非回文，即刻退出循环。
    //另外，负数肯定不是回文，所以单独拎出来做一个判断。
    var isPalindrome = function(s) {
     if(s<0) return false
        s=s.toString()
        let flag = true
        console.log(s,s.length)
        for(let left =0,right=s.length;left<right/2;left++){
            console.log(s[left,s[right-1-left]])
            if(s[left] !== s[right-1-left]){
                flag = false
                break;
            }
        }
        return flag
    };
    ```
- 表示数值的字符串
    ```javascript
    //请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是
    //1.只能出现数字、符号位、小数点、指数位   2.小数点，指数符号只能出现一次、且不能出现在开头结尾 3.指数位出现后，小数点不允许在出现   4.符号位只能出现在开头和指数位后面
    var isNumeric = function(s){
        if(s == undefined) return false
        var hasPoint = false;
        var hasExp = false;
        for(let i=0;i<s.length;i++){
            const target = s[i]
            if (target >= 0 && target <= 9) { //数字
                continue;
            }else if(target === 'e' || target === 'E'){ //判断 是否是指数呼号
                if(hasExp || i=== 0 || i === s.length-1){//判断指数符号只能出现一次、且不能出现在开头结尾
                    return false
                }else{
                    hasExp = true
                    continue
                }
            }else if(target === '.'){ //判断是否是小数点
                if(hasPoint || i === 0 || i === s.length-1){///判断.只能出现一次、且不能出现在开头结尾
                    return false
                }else{
                    hasPoint = true
                    continue
                }
            }else if(target === '+' || target === '-'){//判断是否是符号位
                if(i === 0 || s[i-1] === 'e' || s[i-1] === 'E'){//符号位只能出现在开头和指数位后面
                    continue
                }else{
                    return false
                }
            }else{
                return false
            }
        }
        return true 
    }
    ```
- 字符串排列
    ```javascript
    //输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba
    //使用回溯法
    //1. 记录一个字符（temp），用于存储当前需要进入排列的字符
    //2. 记录一个字符串（current），用于记录当前已经排列好的字符
    //3. 记录一个队列（queue），用于存储还未被排列的字符
    //4. 每次排列将temp添加到current
    //5. 如果queue为空，则本次排列完成，将curret加入到结果数组中，结束递归
    //6. 如果queue不为空，说明还有未排列的字符
    //7. 递归排列queue中剩余的字符
    //8. 为了不影响后续排列，每次递归完成，将当前递归的字符temp加回队列
    var permute = function(str) {
        let queue = str.split('')//拿到当前的字符串数组
        let res=[];
        dfs(res,[],queue);
        return res;
    };
    var dfs= function(res,path,queue){
        //判断是否到叶子节点，存下当前路径的所有值
        if(path.length === queue.length){
          res.push([...path]);
          return;
        }
        for(let i=0;i<queue.length;i++){
          //数组中未存在某个值，则将这个值存入path中，继续搜索下一层，最后恢复现场
          if(path.indexOf(queue[i]) === -1){
            path.push(queue[i]);
            dfs(res,path,queue);
            path.pop();
          }
        }
    }
    ```
- 字符串翻转
    ```javascript
    //题目1:输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student."，则输出"student. a am I"
    //利用api
    var ReverseSentence = function(str){
        return str.split(' ').reverse().join(' ')
        return str.trim().replace(/\s+/g, ' ').split(' ').reverse().join(' '}
    }
    //双端队列
    //1. 首先去除字符串左右空格   2. 逐个读取字符串中的每个单词，依次放入双端队列的对头
    //3. 再将队列转换成字符串输出（已空格为分隔符）
    var reverseWords = function(s) {
        let left = 0
        let right = s.length - 1
        let queue = []
        let word = ''
        while (s.charAt(left) === ' ') left ++
        while (s.charAt(right) === ' ') right --
        console.log('========left',left)
        console.log('==========right',right)
        while (left <= right) {
            let char = s.charAt(left)
            if (char === ' ' && word) {//如果当前位置是空格且word有值，则把word添加进去
                queue.unshift(word)
                word = ''
            } else if (char !== ' '){如果不为空，则word+=char
                word += char
            }
            left++
        }
        queue.unshift(word)//头部添加
        return queue.join(' ')
    };

    //题目2:左旋转字符串
    //字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如输入字符串"abcdefg"和数字2，该函数将返回左旋转2位得到的结果"cdefgab"
    //将两个str进行拼接，直接从第n位开始截取，就相当于将前面n个数字移到末尾。abcdefgabcdefg
    var LeftRotateString = function(str,n){
        if(str&& n!==null){
            return (str+str).substr(n,n.length)
        }
    }
    ```
- 字符流中第一个不重复的字符
    ```javascript
    //请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。 当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。如果当前字符流没有存在出现一次的字符，返回#字符。
    //利用哈希表实现 
    var firstUniqChar = function(s) { 
        const size = s.length 
        let dict = {} 
        for(let i = 0; i < size; i++) { 
            if(dict[s[i]] === false || dict[s[i]]){ 
                dict[s[i]] = false 
            }else{
                dict[s[i]] = true
            } 
        } 
        for(let j = 0; j <size; j++) { 
            if(dict[s[j]]){ 
                return s[j] 
            }
        } 
        return #
    };

    ```
- 最后一个单词的长度
    ```javascript
    //给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。
    //题中的陷阱在于，结尾处仍然可能有空格。一般的解题思路为，先去掉末尾的空格，然后从尾向前开始遍历，直到遇到第一个空格处结束。
    var lengthOfLastWord = function(str){
        if(str === null || str.length === 0) return 0
        var count = 0
        for(let i=str.length-1;i>=0;i++){//从尾部开始
            if(str.charAt(i) === ' '){
                if(count = 0) continue
                break;
            }
            count ++
        }
        return count
    }
    //利用api
    var lengthOfLastWord2 = function(str){
        str = str.trim() //去除头尾空格
        var start = str.lastIndexOf(' ')+1//找到最后一个空格的index
        return str.substring(start).length //截取最后一个单词返回长度
        //利用api2
        var strArr = str.split(' ')//通过split分割
        if(strArr.length< 1) return 0
        return strArr[strArr.length-1].length // 定位到最后一个单词返回长度xs
    }

    ```
- 最长回文子串
    ```javascript
    //给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
    //动态规划
    //1. 利⽤动态规⾃底往上，从最短的字符串出发，记录每⼀级字符串是否是回⽂字符串 
    //2. 当字符串⻓度为零的时候，必为回⽂ 
    //3. 当字符串的⻓度⼩于等于2时，只需要左字符等于右字符，为回⽂ 
    //4. 当字符串的⻓度⼤于等于三时，需要左字符等于右字符且⼦串也为回⽂
    var longestPalindrome = function(s){
        var max = -1
        var size = s.length
        var dp = []
        for(let i=0;i<size;i++){
            dp[i] = []
        }
        let str = '';
        for(let len=0;len<size;len++){
            for(let left =0;left +len<size;left++){
                let right = left+len
                if(len === 0){  //子串长度为0 
                    dp[left][right] = true
                }else if( len <=2){ //子串长度为<=2
                    dp[left][right] = s[left] === s[right]
                }else{//子串长度>=3  
                    dp[left][right] = s[left] === s[right] && dp[left+1][right-1]
                }
                if(dp[left][right] && len>max){
                    max = len
                    str = s.substr(left, len + 1)
                }
            }
        }
        return str
    }

    //1. 状态定义：dp[i,j]：字符串s从索引i到j的子串是否是回文串 true表示子串是回文串
    //2. 转移方程：dp[i][j] = dp[i+1][j-1] && s[i] == s[j] 
        // s[i] == s[j]：说明当前中心可以继续扩张，进而有可能扩大回文串的长度
        // dp[i+1][j-1]：true  说明s[i,j]的**子串s[i+1][j-1]**也是回文串   i是从最大值开始遍历的，j是从最小值开始遍历的
        // j - i < 2：意即子串是一个长度为0或1的回文串
        //总结：dp[i][j] = s[i] == s[j] && ( dp[i+1][j-1] || j - i < 2)
    var longestPalindrome = function(s){
        let n = s.length
        let res;
        for(let i=0;i<size,i++){
            dp[i] = []
        }
        for(let i = n-1 ; i>0; i++){
            for (let j=i ; j<n ;j++){
                 dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i+1][j-1]);
                 if(dp[i][j] && j-i +1>res.length){ // 判断是否是最长的子串
                     res = s.substring(i,j+1)
                 }
            }
        }
        return res
    }
        
    ```
- 最长公共前缀
    ```javascript
    //编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。
    //1. 当字符串数组长度为 0 时则公共前缀为空，直接返回
    //2. 令最长公共前缀 ans 的值为第一个字符串，进行初始化
    //3. 遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀
    //4. 如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回
    //5. 时间复杂度：O(s)O(s)，s 为所有字符串的长度之和
    var longestCommonPrefix = function(strs){
        if(strs.length === 0) return ""
        let first = strs[0]
        for(let i =0 ;i<strs.length;i++){
            for(let j =0 ;j<first.length && j<strs[i].length;j++){
                if(first[j] !== strs[i][j]){
                    break
                }
            }
            first = first.substr(0,i)
            if(first=== '') return first
        }
        //简化一下
        strs.map(item=>{
            let i = 0;
            // i 不会⼤于公共前缀的⻓度  i 不会⼤于单个字符串的⻓度且需要字符相等
            while(i<first.length && i<item.length && first[i]===item[i]){
                i++
            }
            first = i>0 ? item.substring(0, i) : "";
        })
        return first
    }
    ```
- 无重复字符的最长子串
    ```javascript
    //给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。如"abcabcbb" 输出3
    //思路：维护数组    使用一个数组来维护滑动窗口 
        //1. 遍历字符串，判断字符是否在滑动窗口数组里
        //2. 不在则 push 进数组
        //3. 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组
        //4. 然后将 max 更新为当前最长子串的长度
        //5. 遍历完，返回 max 即可
    //时间复杂度：O(n<sup>2</sup>)， 其中 arr.indexOf() 时间复杂度为 O(n) ，arr.splice(0, index+1) 的时间复杂度也为 O(n)
    var lengthOfLongestSubstring = function(s){
        var arr =[],max =0;
        for(let i=0;i<s.length;i++){
            let index = arr.indexOf(s.charAt(i)) //找到当前字符在数组中的位置
            if(index!== -1){//arr中有 则删除滑动窗口数组里相同字符及相同字符前的字符
                arr.splice(0,index+1)
            } 
            arr.push(s.charAt(i)) //不存在就push进数组
            max = Math.max(arr.length,max)
        }
        return max
    }
    //维护下标
    var lengthOfLongestSubstring2 = function(s){
        let index =0 ,max =0 ;
        for(let i=0,j=0;j<s.length;j++){
            let curr = s[j]
            let currIndex = s.substring(i,j).indexOf(curr) // 判断子串中是否存在
            if(currIndex !== -1){
                i = i+index+1
            }
            max = Math.max(max,j-i+1)
        }
        return maxi
    }
    //优化的map
        //使用 map 来存储当前已经遍历过的字符，key 为字符，value 为下标
        //使用 i 来标记无重复子串开始下标，j 为当前遍历字符下标
        //遍历字符串，判断当前字符是否已经在 map 中存在，存在则更新无重复子串开始下标 i 为相同字符的下一位置，此时从 i 到 j 为最新的无重复子串，更新 max ，将当前字符与下标放入 map 中
        //最后，返回 max 即可
    var lengthOfLongestSubstring3 = function(s){
        let map = new Map(),max =0;
        /
        for(let i=0,j=0;j<s.length;j++){
            if(map.has(s[j])){
                i = Math.max(map.get(s[j])+1,i) //更新无重复子串开始下标 i
            }
            max = Math.max(max, j - i + 1)
            map.set(s[j], j) //将当前字符与下标放入 map 中
        }
        return max
    }
    ```
- 字符串相乘
    ```javascript
    //给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
    //我们通过一个长度为num1.length + num2.length的辅助数组ansArr存储每2个数的乘积结果，这个数组，该数组初始化值为0，即[0, 0, 0, 0, 0, 0]。具体的保存结果过程为：
    //：当[2, 3, 4]取索引2上的值i = 2，同样取[4, 5, 6]上索引为2的值 j = 2;
    //let mult = num1[i] * num2[j] = 4 * 6 = 24
    //let sum = mult + ansArr[i+j+1]
    //对sum取余树： sum %10 = 4   ansArr[i+j+1] = 4
    //对sum取整表示进位： sum/10|0 = 2   ansArr[i+j] +=2
    //对结果进行分析：000123 去掉头部的0 shift
    var multiply = function(num1,num2){
        let len1 = num1.length;
        let len2 = num2.length;
        for(let i=len1-1;i>=0;i--){
            for(let j=len2-1;j>=0;j--){
                let sum = num1[i] *num2[j] +ansArr[i+j+1]
                ansArr[i+j+1] = sum % 10
                ansArr[i+j] += sum/10|0
            }
        }
        while(ansArr[0] === 0) ansArr.shift()
        return ansArr.length>0 ansArr.join(''):'0'
    }
    ```