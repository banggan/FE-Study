### 二叉树
#### 二叉树概念
>二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。
#### 二叉树遍历
>同时掌握递归和非递归，非递归重于递归
- 二叉树的中序遍历     (左子树中序遍历 + 跟节点 + 右字数中序遍历)
  ```javascript
  输入: [1,null,2,3]
   1
    \
     2
    /
   3
  输出: [1,3,2]
  //代码实现
  //1.递归写法
  var inorderTraversal = function (root,array= []) {
      if (root) {
        inorderTraversal(root.left, array);
        array.push(root.val);
        inorderTraversal(root.right, array);
      }
      return array;
  };
  //2.非递归
  //思路：1.取跟节点为目标节点，开始遍历   2.左孩子入栈 -> 直至左孩子为空的节点  3.节点出栈 -> 访问该节点  4.以右孩子为目标节点，再依次执行1、2、3
    var inorderTraversal2 = function (root) {
      const result = [];//结果
      const stack = []; // 中间存储中心
      let current = root; //根结点
      while (current || stack.length > 0) {
        while (current) {
          stack.push(current); 
          current = current.left;
        }
        current = stack.pop();
        result.push(current.val);
        current = current.right;
      }
      return result;
    };
  ```
- 二叉树的前序遍历     (跟节点 + 左子树前序遍历 + 右子树前序遍历)r
    ```javascript
    输入: [1,null,2,3]
    1
     \
      2
     /
    3
  输出: [1,2,3]
  //代码实现
  //1.递归写法
  var preorderTraversal = function(root,array=[]){
      if(root){
          array.push(root.val)
          preorderTraversal(root.left,array)
          preorderTraversal(root.right,array)
      }
      return array
  }
  //2.非递归写法
  //思路：1.取根结点为目标节点，开始遍历   2.访问目标节点  3.左孩子入栈--直到左孩子为空的节点   4.节点出栈，以右孩子为目标节点，重复1.2.3
  var preorderTraversal2 = function(root){
      const result = [];
      const stack = [];
      let current = root; //根结点
      while(current || stack.length>0){
          while(current){
              result.push(current.val) //访问目标节点
              stack.push(current)
              current = current.left
          }
          current = stack.pop()
          current = current.right
      }
      return result
  }
    ``` 
- 二叉树的后序遍历     (左子树后序遍历 + 右子树后序遍历 + 跟节点)
    ```javascript
    输入: [1,null,2,3]  
    1
     \
      2
     /
    3 
    输出: [3,2,1]
    //代码实现
    //1.递归写法
    var postorderTraversal =function(root,array=[]){
        if(root){
            postorderTraversal(root.left,array)
            postorderTraversal(root.right,array)
            array.push(root.val)
        }
        return array;
    }
    //2.非递归写法
    //思路：1.取根结点为目标节点    2.左孩子入栈----直到左孩子为空的节点  3.栈顶节点的右节点为空或被访问过，节点出栈并访问他，将节点标记为已访问  4.栈顶节点的右节点不为空且未被访问，以右孩子为目标节点，再依次执行1、2、3
    var postorderTraversal2 = function(root){
      const result = [];
      const stack = [];
      let last = null; // 标记上一个访问的节点
      let current = root;
      while (current || stack.length > 0) {
        while (current) {
          stack.push(current);
          current = current.left;
        }
        current = stack.pop();
        if (!current.right || current.right == last) {
          current = stack.pop();
          result.push(current.val);
          last = current;
          current = null; // 继续弹栈
        } else {
          current = current.right;
        }
      }
      return result;
    }
    ```
- 重建二叉树 (根据前序和中序的特点、中序和后序的特点)
    ```javascript
    //1.输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回
    //规律：1.前序遍历获得根结点root   2.找到root在中序遍历的位置 -> 左子树的长度和右子树的长度   3.截取左子树的中序遍历、右子树的中序遍历    4.截取左子树的前序遍历、右子树的前序遍历   5.递归重建二叉树
    var reConstructBinaryTree = function(pre, vin) {
        if(pre.length === 0){
            return null;
        }
        if(pre.length === 1){
            return new TreeNode(pre[0]);
        }
        const value = pre[0];
        const node = new TreeNode(value);
        if(pre.length>1){
            const index = vin.indexOf(value); 
            if(index >0){
                 const vinLeft = vin.slice(0,index); //左子树
                 const preLeft = pre.slice(1,index+1);
                 node.left = reConstructBinaryTree(preLeft, vinLeft);
            } 
            if(index+1<vin.length){
                const vinRight = vin.slice(index+1); //右子树
                const preRight = pre.slice(index+1);
                node.right = reConstructBinaryTree(preRight, vinRight);
            } 
        }
        return node;
    }
    //2.根据中序和后序，重建二叉树
    //思路：1.后序的最后一个元素获得根结点,根据这个值可以把中序遍历的值分为分为左右两部分，左边是左子节点的值，右边是右子节点的值。2.这个值处于中序遍历的第一个，说明当前节点没有左子节点；如果不是第一个，可以通过截取数组获得以左子节点为根节点中序遍历值和后序遍历的值，递归构建左子节点 3.如果这个值处于中序遍历的最后一个，说明当前节点没有右子节点；如果不是最后一个，可以通过截取数组获得以右子节点为根节点中序遍历值和后序遍历的值，递归构建右子节点。
    //代码
    var buildTree = function(inorder, postorder) {
        if(inorder.length == 0){
          return null
        }  
        var root = postorder[postorder.length -1]
        var newRoot = new TreeNode(root)
        if(inorder.length>1){
            var index = inorder.indexOf(root)
            if(index>0){//有左节点
                var inorderLeft = inorder.slice(0,index)
                var postorderLeft = postorder.slice(0,index)
                newRoot.left = buildTree(inorderLeft,postorderLeft)
            }
            if(index +1 <inorder.length){//有右节点
                var inorderRight = inorder.slice(index+1)
                var postorderRight = postorder.slice(index,postorder.length-1)
                newRoot.right = buildTree(inorderRight,postorderRight)
            }
        } 
        return newRoot   
    };
    //3.给定一棵二叉树的前序遍历和中序遍历，求其后序遍历
    //思路：1.前序遍历找到根结点root   2.找到root在中序遍历的位置 -> 左子树的长度和右子树的长度    3.截取左子树的中序遍历、右子树的中序遍历    4.截取左子树的前序遍历、右子树的前序遍历     5.递归拼接二叉树的后序遍历
    var reConstructPostorder = function（pre,vin){
        if(pre.length ===0){return null}
        if(pre.length === 1){ return new TreeNode(pre[0]);}
        const index = vin.indexOf(pre[0])
        const vinLeft = vin.slice(0,index)
        const vinRight = vin.slice(index+1)
        const preLeft = pre.slice(1,index+1)
        const preRight = pre.slice(index+1)
        return reConstructPostorder(preLeft,vinLeft) + reConstructPostorder(preRight,vinRight) +pre[0] 
    }
    ```
#### 二叉树的对称性
- 对称二叉树
二叉树的右子树是二叉树左子树的镜像二叉树,镜像二叉树：两颗二叉树根结点相同，但他们的左右两个子节点交换了位置.    
    - 条件1.两个根结点相等   
    - 条件2.左子树的右节点和右子树的左节点相同 
    - 条件3.右子树的左节点和左子树的右节点相同
    ```javascript
    //题目：实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
    //代码：
    var isSymmetrical(pRoot) {
      return isSymmetricalTree(pRoot, pRoot);
    }
    var isSymmetricalTree = function(node1,node2){
        if(!node1 && !node2){ // 两个均为空
            return true
        }
        if(!node1 || !node2){//其中一个为空
            return false
        }
        if(node1.val !==node2.val){//节点值不一样
            return false
        }
        return isSymmetricalTree(node1.left,node2.right) && isSymmetricalTree(node1.right,node2.left)
    }
    ```
- 二叉树的镜像
递归交换二叉树所有节点左右节点的位置
    ```javascript
    //题目：操作给定的二叉树，将其变换源二叉树的镜像。
    var Mirror = function(root){
        if(root){
            const temp = root.right;
            root.right = root.left;
            root.left = temp;
            Mirror(root.right)
            Mirror(root.left)
        }
    }
    ```
#### 二叉搜索树
>二叉搜索树（Binary Search Tree，简称 BST）是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。
>若任意节点的左⼦子树不不空，则左⼦子树上所有结点的值均⼩小于它的 根结点的值;
>若任意节点的右⼦子树不不空，则右⼦子树上所有结点的值均⼤大于它的 根结点的值;
>任意节点的左、右⼦子树也分别为⼆二叉查找树。
- 判断 BST 的合法性
    ```javascript
    var isValidBST = function(TreeNode root) {
        return isValidBST2(root, null, null);
    }
    var isValidBST2 = function(root,min,max){
        if(root === null){return true}
        if(min !== null && root.val <= min.val){return false}
        if(max !== null && root.val >= max.val){return false}
        return isValidBST2(root.left,min,root) && isValidBST2(root.right,root,max)
    }
    ```
- 在 BST 中查找一个数是否存在**
    ```javascript
    //利用BST的性质
    var isInBST = function(root,target){
        if(root === null){return false}
        if(root.val === target){return true}
        if(root.val > target){
            return isInBST(root.left,target)
        }
        if(root.val < target){
            return isInBST(root.right,target)
        }
    }
    ```
- 抽象出一套**针对 BST 的遍历框架**：
    ```javascript
    var BST = function( root, target) {
        if (root.val == target)
            // 找到目标，做点什么
        if (root.val < target) 
            BST(root.right, target);
        if (root.val > target)
            BST(root.left, target);
    }
    ```
- 在 BST 中插入一个数
    ```javascript
    var insertIntoBST = function(root,val){
        if(root === null) return new TreeNode(val);
        //if (root.val == target)
            // BST 中一般不会插入已存在元素
        if (root.val < val) 
            insertIntoBST(root.right, val);
        if (root.val > val)
            insertIntoBST(root.left, val);
        return root
    }
    ```
- 在 BST 中删除一个数：跟插入操作类似，先“找”再“改”
    ```javascript
    var getMin = function(root){
        while(root.left !==null){
            root = root.left // BST 最左边的就是最小的
        }
        return root
    }
    var deleteNode = function(root,val){
        if (root.val == target)//找到目标节点
            //情况1: A 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。
            if(root.left === null && root.right === null) return null;
            //情况2: A 只有一个非空子节点，那么它要让这个孩子接替自己的位置。
            if(root.left === null) return root.right
            if(root.right === null) return root.left
            //情况3: A 有两个子节点，麻烦了，为了不破坏 BST 的性质，A 必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。
            if(root.left !== null && root.right !== null){
                TreeNode minNode = getMin(root.right);  //找到右子树的最小节点
                root.val = minNode.val; //把 root 改成 minNode
                root.right = deleteNode(root.right, minNode.val);// 转而去删除 minNode
            }
        if (root.val < val) 
            deleteNode(root.right, val);
        if (root.val > val)
            deleteNode(root.left, val);
        return root
    }
    ```
- 二叉搜索树的第k个节点
    ```javascript
    //给定一棵二叉搜索树，请找出其中的第k小的结点。 例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。
    //思路：二叉搜索树的中序遍历即排序后的节点，本题实际考察二叉树的遍历
    //解发1: 递归找到二叉搜索树的中序遍历
    var loopThrough = function(node){
        let arr = []
        if(node){
            loopThrough(node.left);
            arr.push(node.val);
            loopThrough(node.right)
        }
        return arr
    }
    
    var KthNode = function(rnode,k){
        let kthNodeArr = loopThrough(rnode)
        if(k>0 && k <= kthNodeArr.length){
            return kthNodeArr[k-1]
        }
        return null
    }
    //非递归的方法
    var KthNode2= function(rnode,k){
        var arr = [];
        var stack = [];
        let current = rnode;
        while(current || stack.length>0){
            while(current){
                stack.push(current)
                current = current.left
            }
            current = stack.pop()
            arr.push(current.val)
            current = current.right
        }
        if(k>0 && k<= arr.length){
            return arr[k-1]
        }
        return null
    }
    ```
- 二叉搜索树的后序遍历
    ```javascript
    //输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
    //思路：
    //1.最后一个节点为跟节点，第二部分为左子树的值比跟节点都小，第三部分为右子树的值比跟节点都大。
    //2.先检测左子树，左侧比跟节点小的值都判定为左子树。
    //3.除最后一个节点外和左子树外的其他值为右子树，右子树有一个比跟节点小，则返回false。
    //4.若存在，左、右子树，递归检测左、右子树是否复合规范。
    var VerifySquenceOfBST = function(arr){
        if (arr && arr.length > 0) {
            var root = arr[arr.length - 1] //跟节点
            for (var i = 0; i < arr.length - 1; i++) {
              if (arr[i] > root) {
                break;
              }
            }
            for (let j = i; j < arr.length - 1; j++) {
              if (arr[j] < root) {
                return false;
              }
            }
            var left = true;
            if (i > 0) {
              left = VerifySquenceOfBST(arr.slice(0, i));
            }
            var right = true;
            if (i < arr.length - 1) {
              right = VerifySquenceOfBST(arr.slice(i, arr.length - 1));
            }
            return left && right;
        }
    }
    ```

#### 二叉树的深度
- 二叉树的最大深度
    ```javascript
    
    ```
- 二叉树的最小深度
    ```javascript
    
    ```
- 平衡二叉树
    ```javascript
    
    ```