### 二叉树
#### 二叉树概念
>二叉树是一种典型的树树状结构。如它名字所描述的那样，二叉树是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。
#### 二叉树遍历
>同时掌握递归和非递归，非递归重于递归
- 二叉树的中序遍历     (左子树中序遍历 + 跟节点 + 右字数中序遍历)
  ```javascript
  输入: [1,null,2,3]
   1
    \
     2
    /
   3
  输出: [1,3,2]
  //代码实现
  //1.递归写法
  var inorderTraversal = function (root,array= []) {
      if (root) {
        inorderTraversal(root.left, array);
        array.push(root.val);
        inorderTraversal(root.right, array);
      }
      return array;
  };
  //2.非递归
  //思路：1.取跟节点为目标节点，开始遍历   2.左孩子入栈 -> 直至左孩子为空的节点  3.节点出栈 -> 访问该节点  4.以右孩子为目标节点，再依次执行1、2、3
    var inorderTraversal2 = function (root) {
      const result = [];//结果
      const stack = []; // 中间存储中心
      let current = root; //根结点
      while (current || stack.length > 0) {
        while (current) {
          stack.push(current); 
          current = current.left;
        }
        current = stack.pop();
        result.push(current.val);
        current = current.right;
      }
      return result;
    };
  ```
- 二叉树的前序遍历     (跟节点 + 左子树前序遍历 + 右子树前序遍历)r
    ```javascript
    输入: [1,null,2,3]
    1
     \
      2
     /
    3
  输出: [1,2,3]
  //代码实现
  //1.递归写法
  var preorderTraversal = function(root,array=[]){
      if(root){
          array.push(root.val)
          preorderTraversal(root.left,array)
          preorderTraversal(root.right,array)
      }
      return array
  }
  //2.非递归写法
  //思路：1.取根结点为目标节点，开始遍历   2.访问目标节点  3.左孩子入栈--直到左孩子为空的节点   4.节点出栈，以右孩子为目标节点，重复1.2.3
  var preorderTraversal2 = function(root){
      const result = [];
      const stack = [];
      let current = root; //根结点
      while(current || stack.length>0){
          while(current){
              result.push(current.val) //访问目标节点
              stack.push(current)
              current = current.left
          }
          current = stack.pop()
          current = current.right
      }
      return result
  }
    ``` 
- 二叉树的后序遍历     (左子树后序遍历 + 右子树后序遍历 + 跟节点)
    ```javascript
    输入: [1,null,2,3]  
    1
     \
      2
     /
    3 
    输出: [3,2,1]
    //代码实现
    //1.递归写法
    var postorderTraversal =function(root,array=[]){
        if(root){
            postorderTraversal(root.left,array)
            postorderTraversal(root.right,array)
            array.push(root.val)
        }
        return array;
    }
    //2.非递归写法
    //思路：1.取根结点为目标节点    2.左孩子入栈----直到左孩子为空的节点  3.栈顶节点的右节点为空或被访问过，节点出栈并访问他，将节点标记为已访问  4.栈顶节点的右节点不为空且未被访问，以右孩子为目标节点，再依次执行1、2、3
    var postorderTraversal2 = function(root){
      const result = [];
      const stack = [];
      let last = null; // 标记上一个访问的节点
      let current = root;
      while (current || stack.length > 0) {
        while (current) {
          stack.push(current);
          current = current.left;
        }
        current = stack[stack.length - 1];
        if (!current.right || current.right == last) {
          current = stack.pop();
          result.push(current.val);
          last = current;
          current = null; // 继续弹栈
        } else {
          current = current.right;
        }
      }
      return result;
    }
    ```
- 重建二叉树 (根据前序和中序的特点)
    ```javascript
    //1.输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回
    //规律：1.前序遍历获得根结点root   2.找到root在中序遍历的位置 -> 左子树的长度和右子树的长度   3.截取左子树的中序遍历、右子树的中序遍历    4.截取左子树的前序遍历、右子树的前序遍历   5.递归重建二叉树
    var reConstructBinaryTree = function(pre, vin) {
        if(pre.length === 0){
            return null;
        }
        if(pre.length === 1){
            return new TreeNode(pre[0]);
        }
        const value = pre[0];
        const index = vin.indexOf(value);
        const vinLeft = vin.slice(0,index); //左子树
        const vinRight = vin.slice(index+1); //右子树
        const preLeft = pre.slice(1,index+1);
        const preRight = pre.slice(index+1);
        const node = new TreeNode(value);
        node.left = reConstructBinaryTree(preLeft, vinLeft);
        node.right = reConstructBinaryTree(preRight, vinRight);
        return node;
    }
    //2.给定一棵二叉树的前序遍历和中序遍历，求其后序遍历
    //思路：1.前序遍历找到根结点root   2.找到root在中序遍历的位置 -> 左子树的长度和右子树的长度    3.截取左子树的中序遍历、右子树的中序遍历    4.截取左子树的前序遍历、右子树的前序遍历     5.递归拼接二叉树的后序遍历
    var reConstructPostorder = function（pre,vin){
        if(pre.length ===0){return null}
        if(pre.length === 1){ return new TreeNode(pre[0]);}
        const index = vin.indexOf(pre[0])
        const vinLeft = vin.slice(0,index)
        const vinRight = vin.slice(index+1)
        const preLeft = pre.slice(1,index+1)
        const preRight = pre.slice(index+1)
        return reConstructPostorder(preLeft,vinLeft) + reConstructPostorder(preRight,vinRight) +pre[0] 
    }
    ```
