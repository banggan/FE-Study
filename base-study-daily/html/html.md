##### 保障分发到每一个服务器的响应结果都一致。浏览器页面由哪三层构成?

- 结构层：html 构建文件的结构
- 表示层：css 设置文档的呈现效果
- 行为层： js和dom脚本  实现文档的行为

##### html5的语义化？

- 什么是语义化？

  >html5的语义化是指合理的使用语义化的标签来创建页面的结构，如header\footer\nav，从标签上就可以直观的知道这个标签的作用，而不是滥用div;

- 语义化的优点？

  >- 代码结构清晰、易于阅读、利于开发和维护；
  >- 提高用户体验，在样式加载失败的时候，页面结构清晰；
  >- 方便其他设备解析，根据语义渲染页面；
  >- 有利于搜索引擎优化；

- 常用的语义化标签？

  >Article、aside、footer、header、nav、section等

##### Html5 元素分类？

- 结构性元素

  >- Section: 在web页面中，用于区域章节的表述；
  >- header: 页面主题的头部；
  >- footer: 页面主题的底部；
  >- Article： 用于表示一篇文章的主题部分，一般为文字集中显示的区域

  结构性元素主要负责web的上下文结构的定义，确保html文档的完整性；

- 块级元素

  >Aside: 用以表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容；
  >
  >figure：是对多个元素进行组合并展示的元素，通常与figcaption联合使用；
  >
  >code：表示一段代码块；
  >
  >dialog：用于表达人与人之间的对话，该元素还包括dt和dd这两个组合元素，他们常常同时使用。dt用于表示说话者，而dd用来表示说话者的内容。

  块级元素主要完成web页面区域的划分，确保内容的有效分割

- 行内语义元素

  >Metar: 表示特定范围内的数值，可用于工资、数量、百分比等；
  >
  >time：表示时间值；
  >
  >progress：用来表示进度条，可通过对其max、min、step等属性进行控制，完成对进度的表示和监视；
  >
  >video：视频元素，用于支持和实现视频（含视频流）文件的直接播放，支持缓冲预载和多种视频媒体格式；
  >
  >audio：音频元素，用于支持和实现音频（音频流）文件的直接播放，支持缓冲预载和多种音频媒体格式；

  行内语义性元素主要完成web页面具体内容的引用和表述，是丰富内容展示的基础。

- 交互性元素

  >details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与legend交互才会显示出来；
  >
  >datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新；
  >
  >menu：主要用于交互菜单；
  >
  >command：用来处理命令按钮。

  交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础

##### 常见的空元素

- 含义：没有元素内容标记的内容，也称自闭合元素
- 常见的空元素：` <meta> <br><hr><input><img><link>`

##### 表单增强、新增的input类型及属性

- 新类型

  >- color 用于指定颜色的控件
  >
  >- number 用于输入浮点数的控件
  >
  >- tel  用于输入电话号码的控件；换行会被自动从输入的值中移除A，但不会执行其他语法。可以使用属性，比如 pattern 和 maxlength 来约束控件输入的值。恰当的时候，可以应用 :valid 和 :invalid CSS 伪类。
  >
  >- email  用于编辑 e-mail 的字段。 合适的时候可以使用 :valid 和 :invalid CSS 伪类。
  >
  >- url 用于编辑URL的字段
  >
  >- range 用于输入不精确值控件
  >
  >- search 用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。
  >
  >- 与时间相关
  >
  >  - date 用于输入日期的控件（年，月，日，不包括时间）
  >
  >  - time 用于输入不含时区的时间控件
  >
  >  - datatime 用于输入日期和时间的控件（小时，分钟， 秒，基于UTC时区的一小部分。 此功能已从WHATWG HTML中删除。
  >
  >  - datetime-local 用于输入日期时间控件，不包含时区
  >
  >  - month 用于输入年月的控件，不带时区
  >
  >  - week 用于输入一个由星期-年组成的日期，日期不包括时

- 新属性

  >- placeholder 
  >
  >- required 必填项
  >
  >- list 属性规定输入域的 datalist。datalist 是输入域的选项列表
  >
  >- pattern 定义正则
  >
  >- autofocus 属性规定在页面加载时，域自动地获得焦点。
  >
  >- readonly 该字段只读，不能修改
  >
  >- autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。
  >
  >- min/max
  >
  >- step
  >
  >  > min、max 和 step 属性用于为包含数字或日期的 input 类型规定限定（约束）。
  >  >
  >  > max 属性规定输入域所允许的最大值。
  >  >
  >  > min 属性规定输入域所允许的最小值。
  >  >
  >  > Step 属性为输入域规定的合法的数字间隔：如step =3. 则合法的数字-3，0，3，6

##### 认识 SVG？

- 含义：可缩放矢量图形，是一种用于描述基于二维的矢量图形，基于xml的标记语言；
- 特点：可以任意缩放，不会破坏图像的清晰度和细节，边缘清晰，适用于任何分辨率；

##### 浏览器内核

- 认识内核？

  - 渲染引擎：渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息
  - JS引擎：解析和执行 JavaScript来实现网页的动态效果；越来越独立，内核倾向只指渲染引擎；

- 主流浏览器其内核

  >- IE浏览器： trident内核；
  >- 谷歌浏览器： webkit内核===blink内核
  >- opera浏览器：blink内核
  >- safari浏览器： webkit内核
  >- 国产浏览器：双内核（一个负责兼容，一个负责速度） trident+webkit

##### WEB标准以及W3C

- web标准

  >- 分为结构、表现、行为
  >- 一系列标准的集合：结构化标准语言、表现标准语言、行为标准语言
  >- 诞生原因： 为了解决浏览器版本不同，软硬件设备不同导致的多版本开发问题

- w3c：对web标准提出的规范化要求

  >- 结构要求
  >  - 遵循的好处：提升搜索引擎对页面的抓取效率，对SEO有帮助
  >  - 具体： 标签字母小写、标签要闭合、不允许随意嵌套
  >- 表现和行为要求：
  >  - 遵循的好处：使用户浏览着更方便阅读，使网页开发者之间方便交流
  >  - 具体：尽量使用外链css样式表和j s脚本（提升页面渲染速度）；少用行间样式表（结构和样式分离）

##### DTD(Doctype)

- 作用：声明文档的类型风格，告诉浏览器采用何种渲染模式解析页面
- 渲染模式
  - 怪异模式：服务于旧规则，页面以宽松往后兼容的方式展示
  - 标准模式，，服务于标准规则，
  - 近标准模式：基本是标准模型+一些自己的调整
- 意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。

##### meta标签

- 功能：是html标记语言头部很有用的标签，可提供页面的原信息，针对搜索引擎和更新频度的描述和关键词

- 组成

  - http-equiv:  http的文件头作用，可以向浏览器传回一些有用的信息，与之对应的属性值为content,其属性的语法格式：`<meta http-equiv="参数" content="参数变量值">`
  - Name:  主要用于描述网页，与之对应的属性值为`content`，`content`中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。meta标签的`name`属性语法格式:`＜meta name=”参数” content=”具体的参数值”＞`

- 常用的meta标签总结

  - charset: 是声明文档使用的字符编码，解决乱码问题主要用的就是它，值得一提的是，这个**charset一定要写第一行**，不然就可能会产生乱码了

    ```html
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    ```

  - 百度禁止转码: 百度会自动对网页进行转码，这个标准是禁止转码的

    ```html
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    ```

  - seo优化

    ```html
    <!-- 页面关键词 keywords -->
    <meta name ="keywords" content="your keywords" />
    <!--  定义网页作者 author -->
    <meta name="author" content="author address" />
    <!-- 页面描述内容 description -->
    <meta name = "description" content= "your description" />
    ```

  - Viewport: 主要影响移动端的页面布局

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    ```

    >content参数：
    >
    >- width 宽度(数值/device-width)
    >- height 高度(数值/device-height)
    >- initial-scale 初始缩放比例
    >- maximum-scale 最大缩放比例
    >- minimum-scale 最小缩放比例
    >- user-scalable 是否允许用户缩放(yes/no)

- 作用

  >1.搜索引擎优化（SEO）
  >
  >2.定义页面使用语言
  >
  >3.自动刷新并指向新的页面
  >
  >4.实现网页转换时的动态效果
  >
  >5.控制页面缓冲
  >
  >6.网页定级评价
  >
  >7.控制网页显示的窗口

##### label标签

- 作用：用于控制表单控件的关系，点击时自动将焦点移到相关联的控件上
- 属性：for 关联相关的控件。accessKey：设置访问快捷键
- 注意：该标签不能为a和button标签的后代

##### Link 和 import

- 从属和作用

  >Link 是html标签；可以加载css,也可以定义ref属性
  >
  >import是css提供的语法，只有导入css样式表的作用

- 加载顺序

  >Link在页面加载的同时加载css
  >
  >Import引入的css在页面加载完成后加载

- 兼容性问题

  >link是html提供的语法，没有兼容的问题
  >
  >Import是css2.1提供的语法，ie5以上才支持

- DOM的可控性

  >js可以通过插入link标签唉改变样式
  >
  >js不可以通过@import的样式来改变样式

##### target

- 属性作用:指定所连接的页面在浏览器的打开方式

- 取值

  >- _parent: 在父级窗口打开
  >- _blank: 在新窗口打开
  >- _self： 默认值，在当前窗口打开
  >- _top： 在顶级窗口打开

##### Shadow DOM（影子dom）

- 浏览器的一种能力： 渲染时插入独立的dom树
- 特点：1.与原始的dom独立。   2.具有自己的元素和样式
- 作用：1.封装需要隔离外部的文档细节/组件  2.防止开发人员随意修改
- 使用方式：`Node1.attachShadow(Node2), Node2.innerHTML = ....`

##### 浏览器的数据存储方式有哪些

- Cookie

  >h5之前存储主要采用cookie，其缺点在于需要在请求头上带着数据，导致流量增加，存储大小只有4k
  >
  >创建的目的：为了保持http状态；为了识别用户信息而储存在本地上的数据
  >
  >特点： 大小只有4k;缓存个数有限制，有效时间在cookie过期时间之前都有晓

- 使用 User-Agent 检测请求的一致性，设置HttpOnly，可

  以防止客户端脚本访问这个Cookie，从而有效的防止XSS

  攻击；关闭透明化Session ID；更改Session名称

  用户登录时生成新的 Session ID和session storage

- >创建的目的：便于客服端存储
  >
  >相同点：h5提出；大小5M左右；在本地保存
  >
  >不同点：
  >
  >- 有效时间不同：localStorage（以键值对(Key-Value)的方式存储）:永久有效，浏览器关闭数据不丢失
  >
  >​                            Session storage: 数据在当前浏览器关闭后自动删除
  >
  >- 作用域不同：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。
  >
  >  ​					  sessionStorage不在不同的浏览器页面中共享，即使是同一个页面
  >
  >安全性：需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和sessionStorage 中的，因为它们保存在本地容易被篡改，使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。所以千万不要用它们存储你系统中的敏

- Userdata

  >- 特点：
  >  - IE专属 早期IE浏览器用来本地储存数据用的，以文件的形式保存在磁盘上 持久化储存方式
  >  - 可以设置失效日期
  >  - 可储存大小1MB左右
  >- 注意：使用IE条件注释来避免其它浏览器载入上述代码 <!--[if IE]><[end If]--> 

##### 如何实现标签页面的通信？

- Local storage:

  >使用 localStorage.setItem(key,value) 添加内容
  >
  >使用 Storage 事件监听添加、修改、删除的动作
  >
  >```javascript
  >window.onstorage = (e) => {console.log(e)}
  >// 或者这样
  >window.addEventListener('storage', (e) => console.log(e))
  >```

- Cookie+setInterval

  >将要传递的信息储存在 cookie 中,每隔一定时间读取 cookie信息，获取要传递的信息
  >
  >1、在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。 2、由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。这样做确实可以实现我想要的功能，但是这样的方法相当浪费资源。虽然在这个性能过盛的时代，浪费不浪费也感觉不出来，但是这种实现方案，确实不够优雅。

- websocket通讯（HTML5）

  >- WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。
  >
  >- WebSocket连接必须由浏览器发起
  >
  >  - 1.建立在 TCP 协议之上，服务器端的实现比较容易。
  >
  >  - 2.与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
  >  - 3.数据格式比较轻量，性能开销小，通信高效。
  >  - 4.可以发送文本，也可以发送二进制数据。
  >  - 5.没有同源限制，客户端可以与任意服务器通信。
  >  - 6.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

- SharedWorker（html5浏览器的新特性SharedWorker）

  >本质还是单线程，只是利用了浏览器不同JS引擎; 必须在服务器上才跑得动; IE未兼容

##### 谈谈cookie和session的区别？

>- 共同点: 记录用户状态
>
>- 区别
>
>  - Cookie
>
>    - 什么是cookie?
>
>      HTTP Cookie（ Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成了可能。
>
>    - 采用的是在客户端保持状态的方案 即运行在客户端
>
>    - 有大小限制 个数限制
>
>    - 支持跨域访问
>
>  - Session
>
>    - 什么事session?
>
>      Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。
>
>    - 采用的是在服务端保持状态的方案 即运行在服务端
>
>    - 没有大小限制和服务器内存大小有关
>
>    - 过多会增加服务器压力
>
>    - 仅在所在的域名有效
>
>    1，用户第一次访问服务端的时候，服务端根据用户提交的相关信息创建对应的session,请求返回的时候将该session的唯一标准session id返回给浏览器，浏览器接受到服务端返回的session id 后会将该信息存入到cookie 中，同时cookie将记录该sessionID 属于哪一个域名；
>
>    2，当用户第二次访问服务端的时候，请求会自动判断此域名下是否存在cookie信息，如果存在自动将cookie发送给服务端，服务端从cookie中取session id,再根据sessionID查找对应的session信息，如果没有找到说明用户没有登录或者登录失败，如果找到session证明用户已经登陆可执行后面的操作。
>
>    3、根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态
>
>- 既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了Cookie，如何保障整个机制的正常运转？
>
>  - 第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456...。
>
>  - 第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。Token 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将
>
>    Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。
>
>- 如何考虑分布式 Session 问题？
>
>  - 在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。
>  - 分布式 Session 一般会有以下几种解决方案
>    - Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建Session，第二次分发到服务器 B 的现象。
>    - Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保证分发到每一个服务器的响应都一样。
>
>- 各自优势
>
>  - cookie：极高的扩展性和可用性；不需要使用大量的服务器；简单性 Cookie是一种基于文本的轻量结构，包含简单的键值对，结构简单。
>  - session：易于读写；易于站点的用户化
>
>- 常见攻击方式及解决方案
>
>  - cookie
>    - 具体：直接访问Cookie文件查找想要的机密文件；进行Cookie信息传递时被截取；攻击者伪造Cookie信息，客户端获取后进行操作
>    - 解决方案：不要在Cookie中保存敏感信息；不要再Cookie中保存没有经过加密的或者容易被解密的敏感信息；对从客户端获取得的Cookie信息进行严格校验
>  - session
>    - 具体：会话劫持（通过获取用户 Session ID 后，使用该 Session ID 登录目标账号）；会话固定（诱骗受害者使用攻击者指定的会话标识 Session ID 的攻击手段）
>    - 解决方案：使用 User-Agent 检测请求的一致性，设置HttpOnly，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击；关闭透明化Session ID；更改Session名称；用户登录时生成新的 Session ID

##### 谈谈对WebSocket的认识

>- 创建原因：HTTP协议只能由客户端发起 单向连接
>- 是什么？HTML5中的协议，支持持久连接；WebSocket是基于HTTP协议的 借用了Http协议来完成一部分握手；是真正意义上的双向绑定
>- 区别http协议：
>  - http协议不支持持久连接
>  - HTTP1.1 中出现 keep-alive，合并多个http请求
>  - HTTP的生命周期通过Request来界定 一个Request对应一个Response
>  - Response是被动的，不能主动发起
>- 如何模拟双向通信
>  - 短轮询
>    - 客服端定时向服务器发送ajax请求，服务端到请求后马上返回响应信息并关闭连接。
>    - 优点 后端编写容易
>    - 缺点 请求中大半是无用，浪费宽带和服务器资源
>    - 适用 小型应用
>  - 长轮询
>    - 客户端向服务器发送Ajax请求，服务器接到请求后 hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。
>    - 优点 在无消息的情况下不会频繁的请求，耗费资源小
>    - 缺点：服务器hold连接会消耗资源；返回数据顺序无保证，难于管理维护
>  - 长链接
>    - 在页面嵌入一个隐藏iframe，将这个隐藏iframe的src属性设为对一个长连接的请求或是采用 xhr请求，服务器端就能源源不断的往客户端输入数据
>    - 优点：消息及时到达，不发无用请求；管理起来也相对方便
>    - 缺点 服务器维护一个长连接会增加开销

##### 渲染 | 了解网页渲染流程与优化技巧

>- 生成网页的步骤：
>
>  - HTML代码转成DOM（Document Object Model） 解析HTML生成
>  - CSS代码转化成CSSOM（CSS Object Model） 解析CSS生成
>  - 结合DOM和CSSOM生成一颗渲染树 包含每个节点的视觉信息
>  - 生成布局（layout） 将所有渲染树的所有节点进行平面合成
>  - 将布局绘制（paint）在屏幕上
>
>- 重新渲染
>
>  - 包括
>
>    - 重排：
>
>      - 布局改变就会引起重排
>
>        1.添加或删除可见的DOM元素
>
>        2.元素位置改变
>
>        3.元素尺寸改变——边距、填充、边框、宽度和高度
>
>        4.内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
>
>        5.页面渲染器初始化
>
>        6.浏览器窗口尺寸改变——resize事件发生时；
>
>      - 重排一定需要重绘
>
>        var s = document.body.style;
>
>        s.padding = "2px"; // 回流+重绘
>
>        s.border = "1px solid red"; // 再一次 回流+重绘
>
>        s.color = "blue"; // 重绘
>
>        s.backgroundColor = "#ccc"; // 重绘
>
>        s.fontSize = "14px"; // 再一次 回流+重绘
>
>        document.body.appendChild(document.createTextNode('abc!'));// 添加node，再一次 回流+重
>
>    - 重绘：只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。
>
>    - 注意
>
>      所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。
>
>  - 出现d额情况
>
>    - 修改dom
>    - 修改样式表
>    - 用户事件：鼠标悬停、页面滚动、改变窗口
>
>- 渲染规则
>
>  - 样式表越简单，重排和重绘就越快
>  - 重排和重绘的DOM元素层级越高，成本越高
>  - table元素的重排和重绘成本，要高于div元素

##### 性能优化技巧

>- 减少重新渲染的频率
>
>  - DOM的多个读/写操作应该放在一起。不要两个读操作之间，加入一个写操作
>
>  - 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候又要重排
>
>  - 不要一条条地改变样式，通过改变class，csstext，一次改变样式
>
>  - 尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式例如操作Document Fragment 对象；cloneNode 克隆节点操作后替换
>
>  - 使用虚拟DOM的脚本库，比如React，vue等
>
>  - 1.设为dispaly：none（需要一次重排和重绘）后进行n次操作，最后再恢复显示（需要一次重排和重绘）
>
>    2.用两次重新渲染，取代了可能n（可能是个大树）次的重新渲染
>
>    3.只有在必要的时候，才将元素的display属性为可见
>
>    4.visibility:hidden 的元素只对重绘有影响，不影响重排
>
>    5.隐藏后不可见的元素读写不影响重排和重绘使用调整重新渲染的方法 
>
>  - 使用调整重新渲染的方法 可以大幅度提高网页性能
>
>  - 使用 window.requestAnimationFrame()方法：
>
>    - 作用：将某些代码放到下一次重新渲染时执行
>    - 适用：页面滚动事件的监听函数，网页动画
>
>  - 使用 window.requestdleCallback()方法 暂停就 Chrome 支持
>
>- 减少渲染成本
>
>  - position属性为absolute或fixed的元素，重排的开销会比较小（因为他们脱离文档了流，不需要考虑对其他元素的影响，所以用absolute，而少用float）

##### html5概括

>- HTML（超文本标记语言 HyperText Markup Language）的最新本版本
>
>- 新增特性
>
>  - 语义化元素
>
>  - 新的通讯方式:web sockets
>
>  - 缓存
>
>    - 应用程序缓存
>      - 使用方式：`<html manifest="demo.appcache">`manifest `文件的建议的文件扩展是：".appcache"
>      - 优点
>        - 离线浏览 - 用户可在应用离线时使用它们
>        - 更快速度 - 已缓存资源加载得更快
>        - 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。
>      - 区别于浏览器缓存
>    - 浏览器缓存
>      - localstorage
>      - Session storage
>
>  - 多媒体
>
>    - audio
>    - video
>
>  - 3D 图像
>
>    - canvas
>    - webgl:  用canvas元素中的 API 实现 3D图像功能
>    - Svg: 基于XML 直接嵌入到 HTML 中的矢量图形格式
>
>  - 性能 集成
>
>    - Web workers
>
>      - 是什么？
>
>        Web Worker 是为了解决 JavaScript 在浏览器环境中没有多线程的问题。正常形况下，浏览器执行某段程序的时候会阻塞直到运行结束后在恢复到正常状态，而HTML5的Web Worker就是为了解决这个问题，提升程序的执行效率。 所以Web Worker 的最佳使用场景是执行一些开销较大的数据处理或计算任务。
>
>        Web Workers可以让Web应用程序具备后台处理能力，对多线程的支持性非常好。但是在Web Workers中执行的脚本不能访问该页面的window对象，也就是Web Workers不能直接访问Web页面和DOM API。虽然Web Workers不会导致浏览器UI停止响应，但是仍然会消耗CPU周期，导致系统反应速度变慢。
>
>      - web workers的创建
>
>        - worker是一个对象，通过构造函数Worker创建，参数就是一个js文件的路径；文件中的js代码将运行在主线程之外的worker线程；如：`var myWorker = new Worker('worker.js')`
>
>      - 解决的问题: Web Worker 是为了解决 JavaScript 在浏览器环境中没有多线程的问题。
>
>    - History API 允许对浏览器历史记录进行操作
>
>    - XMLHttpRequest Level 2(（XHR）对象可以与服务器交互。)
>
>      - 可以设置HTTP请求的时限
>      - 可以使用FormData对象管理表单数据。
>      - 可以上传文件。
>      - 可以请求不同域名下的数据（跨域请求）
>      - 可以获取服务器端的二进制数据
>      - 可以获得数据传输的进度信息
>      - 老版本XMLHttpRequest对象的缺点
>        - 只支持文本数据的传送，无法用来读取和上传二进制文件。
>        - 传送和接收数据时，没有进度信息，只能提示有没有完成。
>        - 受到"同域限制"（Same Origin Policy），只能向同一域名的服务器请求数据。
>
>    - contenteditable
>
>      - 让元素的区域可编辑，已经标准化
>
>    - requestAnimationFrame 允许控制动画渲染以获得更优性能
>
>    - 拖放 API draggable属性、拖放事件(dragstart、drag、dragenter、dragleave、dragover、drap、dragend)、dataTransfer对象
>
>    - 全屏API
>
>    - 在线和离线事件
>
>  - 设备访问
>
>    - camera:  能够操作计算机的摄像头
>    - 地理位置定位： geolocation
>    - 触控事件
>    - 检测设备方向：横屏还是竖屏
>
>- 最大缺点：浏览器兼容 IE9



